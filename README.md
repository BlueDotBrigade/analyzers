# BlueDotBrigade.Analyzers

**BlueDotBrigade.Analyzers** is a custom Roslyn analyzer that enforces domain-specific naming consistency in C# codebases using a simple XML-based Domain-Specific Language (DSL).

---

## üß© Overview

The analyzer scans identifiers (types, methods, fields, properties, and variables) for disallowed terms defined in a DSL configuration file and reports compile-time diagnostics when blocked words appear.

If the DSL file isn‚Äôt found, a default example configuration is generated automatically.

---

## ‚öôÔ∏è Example DSL Configuration

```xml
<dsl>
  <!-- One-off -->
  <term prefer="Customer" block="Client" case="sensitive"/>

  <!-- One-to-many -->
  <term prefer="Customer" case="sensitive">
    <alias block="Client"/>
    <alias block="Cust"/>
  </term>
</dsl>
```

### Rules

* **`prefer`** ‚Äî the preferred or canonical term
* **`block`** ‚Äî a forbidden or deprecated term
* **`case`** ‚Äî optional; defaults to `sensitive` (`insensitive` also supported)
* **`alias`** ‚Äî nested element for multiple blocked terms

---

## üß± Installation

Add the NuGet package to any project or solution:

```bash
dotnet add package BlueDotBrigade.Analyzers
```

---

## üìÅ Configuration

Place your DSL file (e.g., `dsl.config.xml`) in the solution root or project directory.

Then, expose it as an **AdditionalFile** in `Directory.Build.props`:

```xml
<Project>
  <PropertyGroup>
    <AnalyzerDslFileName>dsl.config.xml</AnalyzerDslFileName>
  </PropertyGroup>

  <ItemGroup>
    <CompilerVisibleProperty Include="AnalyzerDslFileName" />
    <AdditionalFiles Include="$(MSBuildThisFileDirectory)$(AnalyzerDslFileName)" />
  </ItemGroup>
</Project>
```

If no DSL file is found, the analyzer uses a built-in default example.

---

## ü•™ Testing

Unit tests use **MSTest v3+** and **BlueDotBrigade.DatenLokator** for sample input management.

Run all tests with:

```bash
dotnet test
```

---

## üîç Requirements

* .NET SDK **9.0+**
* Visual Studio 2022 (v17.10+) or newer
* Compatible with Roslyn-based tooling (e.g., JetBrains Rider)

---

## üßØ Overriding or Suppressing Rules

Sometimes, specific code or legacy APIs should be excluded from analysis. Roslyn allows you to suppress or override diagnostics in several ways:

### 1. Inline suppression using `#pragma`

```csharp
#pragma warning disable RC001
public class ClientController
{
    // The term ‚ÄúClient‚Äù is blocked in the DSL, but it‚Äôs intentionally allowed here.
    public void Run() { }
}
#pragma warning restore RC001
```

Use this for small code sections or one-off exceptions.

---

### 2. Suppressing at symbol level with `[SuppressMessage]`

```csharp
using System.Diagnostics.CodeAnalysis;

[SuppressMessage("Naming", "RC001:Blocked term in identifier", Justification = "Legacy API naming retained for compatibility.")]
public class LegacyClientController
{
    public void DoWork() { }
}
```

This approach is ideal when you want the suppression to be documented and scoped to a specific symbol.

---

### 3. Configure globally using `.editorconfig`

You can disable or change the severity of specific rules for all code under a directory:

```ini
# Disable the DSL analyzer rule entirely
dotnet_diagnostic.RC001.severity = none

# Or lower the severity
# dotnet_diagnostic.RC001.severity = suggestion
```

Place this in your project‚Äôs or solution‚Äôs `.editorconfig` file.

---

### 4. Ignoring Generated or Auto-Generated Code

Roslyn analyzers automatically skip files marked as generated. If needed, you can mark your file manually:

```csharp
// <auto-generated />
// This file is generated by a tool and should not trigger analyzer diagnostics.
public class AutoGeneratedClient { }
```

---

### 5. Custom Suppression Comments *(Optional Feature)*

If desired, you can extend the analyzer to recognize custom comments like:

```csharp
// AnalyzersIgnore RC001
public class ClientController { }
```

This approach can be added to the analyzer logic for domain-specific suppressions if your team wants lightweight inline control.